///////////////////////////////////////////////////////////////////////////////
///
/// Authors: Chris Peters, Andrea Ellinger
/// Copyright 2017, DigiPen Institute of Technology
///
///////////////////////////////////////////////////////////////////////////////

#pragma once

namespace Zero
{
namespace Tags
{
DeclareTag(Sound);
}

namespace Events
{
  DeclareEvent(MIDINoteOn);
  DeclareEvent(MIDINoteOff);
  DeclareEvent(MIDIPitchWheel);
  DeclareEvent(MIDIVolume);
  DeclareEvent(MIDIModWheel);
  DeclareEvent(MIDIOtherControl);
  DeclareEvent(SoundInstancePlayed);
  DeclareEvent(MicrophoneUncompressedFloatData);
  DeclareEvent(MicrophoneCompressedByteData);
}

//-------------------------------------------------------------------------------------- Sound Event

/// Sent for various audio-related events
class SoundEvent : public Event
{
public:
  ZilchDeclareType(TypeCopyMode::ReferenceType);

};

//--------------------------------------------------------------------------------------- MIDI Event

/// Sent when a MIDI message is received from a connected device.
class MidiEvent : public Event 
{
public:
  ZilchDeclareType(TypeCopyMode::ReferenceType);

  MidiEvent() : 
    Channel(0),
    MIDINumber(0), 
    Value(0) 
  {}
  MidiEvent(float channel, float number, float value) : 
    Channel(channel), 
    MIDINumber(number), 
    Value(value) 
  {}

  /// The MIDI channel received from the device.
  float Channel;
  /// The MIDI note number associated with the message. 
  float MIDINumber;
  /// A value associated with the message. Will be in the range 0 - 127.
  float Value;
};

//--------------------------------------------------------------------------- Audio Float Data Event

class AudioFloatDataEvent : public Event
{
public:
  ZilchDeclareType(TypeCopyMode::ReferenceType);

  HandleOf<ArrayClass<float>> AudioData;
  unsigned Channels;
};

//---------------------------------------------------------------------------- Audio Byte Data Event

class AudioByteDataEvent : public Event
{
public:
  ZilchDeclareType(TypeCopyMode::ReferenceType);

  HandleOf<ArrayClass<byte>> AudioData;
};

//-------------------------------------------------------------------------------------------- Enums

/// The possible settings for the number of channels used by the audio system when creating audio.
/// <param name="AutoDetect">The audio system will match its channels to the default output device.</param>
/// <param name="Mono">Audio will be produced using only a single channel.</param>
/// <param name="Stereo">Audio will be produced using two channels, one for the left speaker and one for the right.</param>
/// <param name="Quad">Audio will be produced using two left channels and two right channels.</param>
/// <param name="FiveOne">Audio will be produced using a typical 5.1 speaker configuration.</param>
/// <param name="SevenOne">Audio will be produced using a typical 7.1 speaker configuration.</param>
DeclareEnum6(AudioMixTypes, AutoDetect, Mono, Stereo, Quad, FiveOne, SevenOne);

/// The latency setting used by the audio system.
/// <param name="Low">The default setting, where audio will have a low amount of latency.</param>
/// <param name="High">Audio will have a higher latency. This can fix some audio problems in some cases.</param>
DeclareEnum2(AudioLatency, Low, High);

//------------------------------------------------------------------------------------- Sound System

///SoundSystem manages audio for the engine.
class SoundSystem : public System, Audio::ExternalSystemInterface
{
public:
  ZilchDeclareType(TypeCopyMode::ReferenceType);

  SoundSystem();
  ~SoundSystem();

  //System Interface
  virtual cstr GetName()override{return "Sound";}
  void Initialize(SystemInitializer& initializer) override;

  /// Used by the SoundNode Graph window to display the current state of connected SoundNodes.
  NodeInfoListType::range GetNodeGraphInfo();
  /// The volume modifier applied to all audio generated by Zero.
  float GetSystemVolume();
  void SetSystemVolume(float volume);
  /// When true, audio will be processed normally but will be silent.
  bool GetMuteAllAudio();
  void SetMuteAllAudio(bool muteAudio);
  /// The current peak volume level of all audio output
  float GetPeakOutputLevel();
  /// The current RMS volume level of all audio output
  float GetRMSOutputLevel();
  /// If currently dispatching either uncompressed or compressed audio input data, this value
  /// will be the highest peak volume in the last batch of input.
  float GetPeakInputLevel();
  /// Using the high latency setting can fix some audio problems (such as clicks and static) 
  /// but can lead to a slight delay in the audio
  AudioLatency::Enum GetLatencySetting();
  void SetLatencySetting(AudioLatency::Enum latency);
  /// If true, MicrophoneUncompressedFloatData events will be sent every update with the buffer of
  /// audio data received from the default audio input device.
  bool GetDispatchMicrophoneUncompressedFloatData();
  void SetDispatchMicrophoneUncompressedFloatData(bool dispatchData);
  /// If true, MicrophoneCompressedByteData events will be sent every update with the buffer of
  /// compressed audio data received from the default audio input device.
  bool GetDispatchMicrophoneCompressedByteData();
  void SetDispatchMicrophoneCompressedByteData(bool dispatchData);
  /// Returns the number of audio channels currently used by the audio engine for audio output.
  int GetOutputChannels();

  /// Creates a new VolumeNode object
  static VolumeNode* VolumeNode() { return new Zero::VolumeNode(); }
  /// Creates a new PanningNode object
  static PanningNode* PanningNode() { return new Zero::PanningNode(); }
  /// Creates a new PitchNode object
  static PitchNode* PitchNode() { return new Zero::PitchNode(); }
  /// Creates a new LowPassNode object
  static LowPassNode* LowPassNode() { return new Zero::LowPassNode(); }
  /// Creates a new HighPassNode object
  static HighPassNode* HighPassNode() { return new Zero::HighPassNode(); }
  /// Creates a new BandPassNode object
  static BandPassNode* BandPassNode() { return new Zero::BandPassNode(); }
  /// Creates a new EqualizerNode object
  static EqualizerNode* EqualizerNode() { return new Zero::EqualizerNode(); }
  /// Creates a new ReverbNode object
  static ReverbNode* ReverbNode() { return new Zero::ReverbNode(); }
  /// Creates a new DelayNode object
  static DelayNode* DelayNode() { return new Zero::DelayNode(); }
  /// Creates a new FlangerNode object
  static FlangerNode* FlangerNode() { return new Zero::FlangerNode(); }
  /// Creates a new ChorusNode object
  static ChorusNode* ChorusNode() { return new Zero::ChorusNode(); }
  /// Creates a new CompressorNode object
  static CompressorNode* CompressorNode() { return new Zero::CompressorNode(); }
  /// Creates a new ExpanderNode object
  static ExpanderNode* ExpanderNode() { return new Zero::ExpanderNode(); }
  /// Creates a new CustomAudioNode object
  static CustomAudioNode* CustomAudioNode() { return new Zero::CustomAudioNode(); }
  /// Creates a new SoundBuffer object
  static SoundBuffer* SoundBuffer() { return new Zero::SoundBuffer(); }
  /// Creates a new GeneratedWaveNode object
  static GeneratedWaveNode* GeneratedWaveNode() { return new Zero::GeneratedWaveNode(); }
  /// Creates a new RecordingNode object
  static RecordingNode* RecordingNode() { return new Zero::RecordingNode(); }
  /// Creates a new AddNoiseNode object
  static AddNoiseNode* AddNoiseNode() { return new Zero::AddNoiseNode(); }
  /// Creates a new AdditiveSynthNode object
  static AdditiveSynthNode* AdditiveSynthNode() { return new Zero::AdditiveSynthNode(); }
  /// Creates a new ModulationNode object
  static ModulationNode* ModulationNode() { return new Zero::ModulationNode(); }
  /// Creates a new MicrophoneInputNode object
  static MicrophoneInputNode* MicrophoneInputNode() { return new Zero::MicrophoneInputNode(); }
  /// Creates a new SaveAudioNode object
  static SaveAudioNode* SaveAudioNode() { return new Zero::SaveAudioNode(); }
  /// Creates a new GranularSynthNode object
  static GranularSynthNode* GranularSynthNode() { return new Zero::GranularSynthNode(); }

//Internals
  void Update(bool debugger) override;
  void StopPreview();
  float PitchToSemitones(float pitch);
  float SemitonesToPitch(float semitones);
  float VolumeToDecibels(float volume);
  float DecibelsToVolume(float decibels);
  void SendAudioEvent(const Audio::AudioEventTypes::Enum eventType, void* data) override;
  void SendAudioError(const Zero::String message) override;
  void AddSoundSpace(SoundSpace* space, bool isEditor);
  void RemoveSoundSpace(SoundSpace* space, bool isEditor);

  unsigned mCounter;
  InList<SoundTag> mSoundTags;
  HandleOf<SoundInstance> mPreviewInstance;
  String mAudioMessage;
  SoundNodeGraph NodeGraph;
  HandleOf<SoundNode> mOutputNode;
  int mSoundSpaceCounter;

private:
  Audio::AudioSystemInterface* mAudioSystem;
  AudioLatency::Enum mLatency;
  bool mSendMicEvents;
  bool mSendCompressedMicEvents;
  InList<SoundSpace> mSpaces;

  friend class AudioSettings;
  friend class AudioStatics;
};

System* CreateSoundSystem();

// Global Access
namespace Z
{
  extern SoundSystem* gSound;
}

//----------------------------------------------------------------------------------- Sound Settings

class AudioSettings : public Component
{
public:
  ZilchDeclareType(TypeCopyMode::ReferenceType);

  AudioSettings() : 
    mSystemVolume(1.0f), 
    mMixType(AudioMixTypes::AutoDetect)
  {}

  void Serialize(Serializer& stream) override;
  void Initialize(CogInitializer& initializer) override;

  /// An overall volume modifier that is applied to all audio produced by Zero.
  float GetSystemVolume();
  void SetSystemVolume(float volume);
  /// When true, audio will be processed normally but will be silent.
  bool GetMuteAllAudio();
  void SetMuteAllAudio(bool muteAudio);
  /// Sets the number of channels the audio system uses when creating audio. See the enum descriptions.
  /// If your selection is different from the output device, it will be automatically translated 
  /// to match the number of channels needed for output.
  AudioMixTypes::Enum GetMixType();
  void SetMixType(AudioMixTypes::Enum mixType);
  /// Sets the volume threshold at which sounds will be virtualized (they will continue
  /// tracking their position and all data but will not process audio). 
  /// This is a floating point volume number, not decibels.
  float GetMinVolumeThreshold();
  void SetMinVolumeThreshold(float volume);
  /// Using the high latency setting can fix some audio problems (such as clicks and static) 
  /// but can lead to a slight delay in the audio
  AudioLatency::Enum GetLatencySetting();
  void SetLatencySetting(AudioLatency::Enum latency);

private:
  float mSystemVolume;
  float mMinVolumeThreshold;
  AudioMixTypes::Enum mMixType;
  AudioLatency::Enum mLatency;
};

}//namespace Zero
